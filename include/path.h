/**
 * @file path.h
 * @author Karl Kurzer
 * @brief 
 * @version 0.1
 * @date 2022-04-15
 * 
 * @copyright Copyright (c) 2022
 * 
 */

#ifndef PATH_H
#define PATH_H

#include <iostream>
#include <cstring>
#include <vector>

#include <ros/ros.h>
#include <tf/transform_datatypes.h>
#include <nav_msgs/Path.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/PoseArray.h>
#include <visualization_msgs/MarkerArray.h>

#include "node3d.h"
#include "constants.h"
#include "helper.h"
namespace HybridAStar {
/**
 * @brief A class for tracing and visualizing the path generated by the Planner
 * 
 */
class Path {
 public:
  /// The default constructor initializing the path object and setting publishers for the same.
  Path(bool smoothed = false) {
    std::string path_topic = "/path";
    std::string path_nodes_topic = "/pathNodes";
    std::string path_vehicle_topic = "/pathVehicle";

    if (smoothed) {
      path_topic = "/sPath";
      path_nodes_topic = "/sPathNodes";
      path_vehicle_topic = "/sPathVehicle";
      is_smoothed_ = smoothed;
    }

    // topics to publish
    path_publisher = n_node_.advertise<nav_msgs::Path>(path_topic, 1);
    path_nodes_publisher = n_node_.advertise<visualization_msgs::MarkerArray>(path_nodes_topic, 1);
    path_vehicles_publisher = n_node_.advertise<visualization_msgs::MarkerArray>(path_vehicle_topic, 1);

    // configure the container
    path.header.frame_id = "path";
  }

  //  // TRACE PATH
  //  /**
  //   * @brief Given a node pointer the path to the root node will be traced recursively
  //   * @param node a 3D node, usually the goal node
  //   * @param i a parameter for counting the number of nodes
  //   */
  //  void tracePath(const Node3D* node, int i = 0);

  /**
   * @brief Given a node pointer the path to the root node will be traced recursively
   * @param node a 3D node, usually the goal node
   * @param i a parameter for counting the number of nodes
   * 
   */
  void UpdatePath(const std::vector<Node3D> &node_path);

  /**
   * @brief Adds a segment to the path
   * @param node a 3D node
   * 
   */
  void AddSegment(const Node3D& node);

  /**
   * @brief Adds a node to the path
   * @param node a 3D node
   * @param i a parameter for counting the number of nodes
   * 
   */
  void AddNode(const Node3D& node, int i);

  /**
   * @brief Adds a vehicle shape to the path
   * @param node a 3D node
   * @param i a parameter for counting the number of nodes
   * 
   */
  void AddVehicle(const Node3D& node, int i);

  /// Clears the path
  void clear();
  /// Publishes the path
  void PublishPath() { path_publisher.publish(path); }
  /// Publishes the nodes of the path
  void PublishPathNodes() { path_nodes_publisher.publish(pathNodes); }
  /// Publishes the vehicle along the path
  void PublishPathVehicles() { path_vehicles_publisher.publish(pathVehicles); }

 private:
  /// A handle to the ROS node
  ros::NodeHandle n_node_;
  /// Publisher for the path as a spline
  ros::Publisher path_publisher;
  /// Publisher for the nodes on the path
  ros::Publisher path_nodes_publisher;
  /// Publisher for the vehicle along the path
  ros::Publisher path_vehicles_publisher;
  /// Path data structure for visualization
  nav_msgs::Path path;
  /// Nodes data structure for visualization
  visualization_msgs::MarkerArray pathNodes;
  /// Vehicle data structure for visualization
  visualization_msgs::MarkerArray pathVehicles;
  /// Value that indicates that the path is smoothed/post processed
  bool is_smoothed_ = false;
};

}  // namespace HybridAStar
#endif // PATH_H
